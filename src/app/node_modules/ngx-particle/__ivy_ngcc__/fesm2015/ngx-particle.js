import { __decorate, __metadata } from 'tslib';
import { Input, Component, ElementRef, HostListener, Directive, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
let ParticlesComponent = class ParticlesComponent {
    constructor() {
        this.width = 100;
        this.height = 100;
        this.style = {};
    }
};
ParticlesComponent.ɵfac = function ParticlesComponent_Factory(t) { return new (t || ParticlesComponent)(); };
ParticlesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ParticlesComponent, selectors: [["particles"]], inputs: { width: "width", height: "height", style: "style", params: "params" }, decls: 2, vars: 6, consts: [[1, "particles-container", 3, "ngStyle"], ["d-particles", "", 3, "params"]], template: function ParticlesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelement(1, "canvas", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngStyle", ctx.style);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.width, "%")("height", ctx.height, "%");
        ɵngcc0.ɵɵproperty("params", ctx.params);
    } }, directives: function () { return [ɵngcc1.NgStyle, ParticlesDirective]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Number)
], ParticlesComponent.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ParticlesComponent.prototype, "height", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ParticlesComponent.prototype, "params", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ParticlesComponent.prototype, "style", void 0);
ParticlesComponent = __decorate([ __metadata("design:paramtypes", [])
], ParticlesComponent);

const hexToRgb = (hex) => {
    let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, (m, r, g, b) => {
        return r + r + g + g + b + b;
    });
    let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
};
const clamp = (number, min, max) => {
    return Math.min(Math.max(number, min), max);
};
const isInArray = (value, array) => {
    return array.indexOf(value) > -1;
};
const deepExtend = function (destination, source) {
    for (let property in source) {
        if (source[property] &&
            source[property].constructor &&
            source[property].constructor === Object) {
            destination[property] = destination[property] || {};
            deepExtend(destination[property], source[property]);
        }
        else {
            destination[property] = source[property];
        }
    }
    return destination;
};
const getColor = (colorObject) => {
    let color = {};
    if (typeof (colorObject) == 'object') {
        if (colorObject instanceof Array) {
            let selectedColor = colorObject[Math.floor(Math.random() * colorObject.length)];
            color.rgb = hexToRgb(selectedColor);
        }
        else {
            let { r, g, b } = colorObject;
            if (r !== undefined && g !== undefined && b !== undefined) {
                color.rgb = { r, g, b };
            }
            else {
                let { h, s, l } = colorObject;
                if (h !== undefined && g !== undefined && b !== undefined) {
                    color.hsl = { h, s, l };
                }
            }
        }
    }
    else if (colorObject == 'random') {
        color.rgb = {
            r: (Math.floor(Math.random() * 255) + 1),
            g: (Math.floor(Math.random() * 255) + 1),
            b: (Math.floor(Math.random() * 255) + 1)
        };
    }
    else if (typeof (colorObject) == 'string') {
        color.rgb = hexToRgb(colorObject);
    }
    return color;
};
const getDefaultParams = () => {
    return {
        particles: {
            number: {
                value: 100,
                density: {
                    enable: true,
                    value_area: 800
                }
            },
            color: {
                value: '#FFF'
            },
            shape: {
                type: 'circle',
                stroke: {
                    width: 0,
                    color: '#000000'
                },
                polygon: {
                    nb_sides: 5
                },
                image: {
                    src: '',
                    width: 100,
                    height: 100
                }
            },
            opacity: {
                value: 0.5,
                random: false,
                anim: {
                    enable: true,
                    speed: 1,
                    opacity_min: 0.1,
                    sync: false
                }
            },
            size: {
                value: 3,
                random: true,
                anim: {
                    enable: false,
                    speed: 40,
                    size_min: 0,
                    sync: false
                }
            },
            line_linked: {
                enable: true,
                distance: 150,
                color: '#FFF',
                opacity: 0.6,
                width: 1,
                shadow: {
                    enable: false,
                    blur: 5,
                    color: 'lime'
                }
            },
            move: {
                enable: true,
                speed: 3,
                direction: 'none',
                random: false,
                straight: false,
                out_mode: 'out',
                bounce: true,
                attract: {
                    enable: false,
                    rotateX: 3000,
                    rotateY: 3000
                }
            },
            array: []
        },
        interactivity: {
            detect_on: 'canvas',
            events: {
                onhover: {
                    enable: true,
                    mode: 'grab'
                },
                onclick: {
                    enable: true,
                    mode: 'push'
                },
                resize: true
            },
            modes: {
                grab: {
                    distance: 200,
                    line_linked: {
                        opacity: 1
                    }
                },
                bubble: {
                    distance: 200,
                    size: 80,
                    duration: 0.4
                },
                repulse: {
                    distance: 200,
                    duration: 0.4
                },
                push: {
                    particles_nb: 4
                },
                remove: {
                    particles_nb: 2
                }
            },
            mouse: {}
        },
        retina_detect: true
    };
};
function loadImg(params, tmp) {
    let { particles } = params;
    tmp.img_error = undefined;
    if (particles.shape.type == 'image' && particles.shape.image.src != '') {
        if (tmp.img_type == 'svg') {
            let xhr = new XMLHttpRequest();
            xhr.open('GET', particles.shape.image.src);
            xhr.onreadystatechange = (data) => {
                if (xhr.readyState == 4) {
                    if (xhr.status == 200) {
                        tmp.source_svg = data.currentTarget.response;
                        if (tmp.source_svg == undefined) {
                            let check;
                            tmp.checkAnimFrame = requestAnimationFrame(check);
                        }
                    }
                    else {
                        tmp.img_error = true;
                        throw "Error : image not found";
                    }
                }
            };
            xhr.send();
        }
        else {
            let img = new Image();
            img.addEventListener('load', () => {
                tmp.img_obj = img;
                cancelAnimationFrame(tmp.checkAnimFrame);
            });
            img.src = particles.shape.image.src;
        }
    }
    else {
        tmp.img_error = true;
        throw "Error : no image.src";
    }
}
function createSvgImg(particle, tmp) {
    let svgXml = tmp.source_svg;
    let rgbHex = /#([0-9A-F]{3,6})/gi;
    let coloredSvgXml = svgXml.replace(rgbHex, (m, r, g, b) => {
        let color_value;
        if (particle.color.rgb) {
            let { r, g, b } = particle.color.rgb;
            color_value = `rgba( ${r}, ${g}, ${b}, ${particle.opacity} )`;
        }
        else {
            let { h, s, l } = particle.color.hsl;
            color_value = `rgba( ${h}, ${s}, ${l}, ${particle.opacity} )`;
        }
        return color_value;
    });
    let svg = new Blob([coloredSvgXml], {
        type: 'image/svg+xml;charset=utf-8'
    });
    let DOMURL = window.URL || window;
    let url = DOMURL.createObjectURL(svg);
    let img = new Image();
    img.addEventListener('load', () => {
        particle.img.obj = img;
        particle.img.loaded = true;
        DOMURL.revokeObjectURL(url);
        tmp.count_svg++;
    });
    img.src = url;
}

class ParticleInteraction {
    constructor() { }
    linkParticles(p1, p2, params, canvasParams) {
        let dx = p1.x - p2.x;
        let dy = p1.y - p2.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        let { line_linked } = params.particles;
        if (dist <= params.particles.line_linked.distance) {
            let opacity_line = params.particles.line_linked.opacity - (dist / (1 / params.particles.line_linked.opacity)) / params.particles.line_linked.distance;
            if (opacity_line > 0) {
                let color_line = params.particles.line_linked.color_rgb_line;
                let { r, g, b } = color_line;
                canvasParams.ctx.save();
                canvasParams.ctx.strokeStyle = `rgba( ${r}, ${g}, ${b}, ${opacity_line} )`;
                canvasParams.ctx.lineWidth = params.particles.line_linked.width;
                canvasParams.ctx.beginPath();
                if (line_linked.shadow.enable) {
                    canvasParams.ctx.shadowBlur = line_linked.shadow.blur;
                    canvasParams.ctx.shadowColor = line_linked.shadow.color;
                }
                canvasParams.ctx.moveTo(p1.x, p1.y);
                canvasParams.ctx.lineTo(p2.x, p2.y);
                canvasParams.ctx.stroke();
                canvasParams.ctx.closePath();
                canvasParams.ctx.restore();
            }
        }
    }
    attractParticles(p1, p2, params) {
        let dx = p1.x - p2.x;
        let dy = p1.y - p2.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        if (dist <= params.particles.line_linked.distance) {
            let ax = dx / (params.particles.move.attract.rotateX * 1000);
            let ay = dy / (params.particles.move.attract.rotateY * 1000);
            p1.vx -= ax;
            p1.vy -= ay;
            p2.vx += ax;
            p2.vy += ay;
        }
    }
    bounceParticles(p1, p2) {
        let dx = p1.x - p2.x;
        let dy = p1.y - p2.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        let dist_p = p1.radius + p2.radius;
        if (dist <= dist_p) {
            p1.vx = -p1.vx;
            p1.vy = -p1.vy;
            p2.vx = -p2.vx;
            p2.vy = -p2.vy;
        }
    }
}

class Particle {
    constructor(_canvasParams, _params, _tmpParams, color, opacity, position) {
        this._canvasParams = _canvasParams;
        this._params = _params;
        this._tmpParams = _tmpParams;
        this._setupSize();
        this._setupPosition(position);
        this._setupColor(color);
        this._setupOpacity();
        this._setupAnimation();
    }
    _setupSize() {
        this.radius = (this._params.particles.size.random ? Math.random() : 1) * this._params.particles.size.value;
        if (this._params.particles.size.anim.enable) {
            this.size_status = false;
            this.vs = this._params.particles.size.anim.speed / 100;
            if (!this._params.particles.size.anim.sync)
                this.vs = this.vs * Math.random();
        }
    }
    _setupPosition(position) {
        this.x = position ? position.x : Math.random() * this._canvasParams.width;
        this.y = position ? position.y : Math.random() * this._canvasParams.height;
        if (this.x > this._canvasParams.width - this.radius * 2) {
            this.x = this.x - this.radius;
        }
        else if (this.x < this.radius * 2) {
            this.x = this.x + this.radius;
        }
        if (this.y > this._canvasParams.height - this.radius * 2) {
            this.y = this.y - this.radius;
        }
        else if (this.y < this.radius * 2) {
            this.y = this.y + this.radius;
        }
        if (this._params.particles.move.bounce) {
            this._checkOverlap(this, position);
        }
    }
    _checkOverlap(p1, position) {
        let { particles } = this._params;
        particles.array.forEach((particle) => {
            let p2 = particle;
            let dx = p1.x - p2.x;
            let dy = p1.y - p2.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            if (dist <= p1.radius + p2.radius) {
                p1.x = position ? position.x : Math.random() * this._canvasParams.width;
                p1.y = position ? position.y : Math.random() * this._canvasParams.height;
                this._checkOverlap(p1);
            }
        });
    }
    _setupColor(color) {
        this.color = getColor(color.value);
    }
    _setupOpacity() {
        this.opacity = (this._params.particles.opacity.random ? Math.random() : 1) * this._params.particles.opacity.value;
        if (this._params.particles.opacity.anim.enable) {
            this.opacity_status = false;
            this.vo = this._params.particles.opacity.anim.speed / 100;
            if (!this._params.particles.opacity.anim.sync) {
                this.vo = this.vo * Math.random();
            }
        }
    }
    _setupAnimation() {
        let velbase = null;
        switch (this._params.particles.move.direction) {
            case 'top':
                velbase = { x: 0, y: -1 };
                break;
            case 'top-right':
                velbase = { x: 0.5, y: -0.5 };
                break;
            case 'right':
                velbase = { x: 1, y: 0 };
                break;
            case 'bottom-right':
                velbase = { x: 0.5, y: 0.5 };
                break;
            case 'bottom':
                velbase = { x: 0, y: 1 };
                break;
            case 'bottom-left':
                velbase = { x: -0.5, y: 1 };
                break;
            case 'left':
                velbase = { x: -1, y: 0 };
                break;
            case 'top-left':
                velbase = { x: -0.5, y: -0.5 };
                break;
            default:
                velbase = { x: 0, y: 0 };
                break;
        }
        if (this._params.particles.move.straight) {
            this.vx = velbase.x;
            this.vy = velbase.y;
            if (this._params.particles.move.random) {
                this.vx = this.vx * (Math.random());
                this.vy = this.vy * (Math.random());
            }
        }
        else {
            this.vx = velbase.x + Math.random() - 0.5;
            this.vy = velbase.y + Math.random() - 0.5;
        }
        this.vx_i = this.vx;
        this.vy_i = this.vy;
        let shape_type = this._params.particles.shape.type;
        if (typeof (shape_type) == 'object') {
            if (shape_type instanceof Array) {
                let shape_selected = shape_type[Math.floor(Math.random() * shape_type.length)];
                this.shape = shape_selected;
            }
        }
        else {
            this.shape = shape_type;
        }
        if (this.shape == 'image') {
            let sh = this._params.particles.shape;
            this.img = {
                src: sh.image.src,
                ratio: sh.image.width / sh.image.height
            };
            if (!this.img.ratio)
                this.img.ratio = 1;
            if (this._tmpParams.img_type == 'svg' && this._tmpParams.source_svg != undefined) {
                createSvgImg(this, this._tmpParams);
                if (this._tmpParams.pushing) {
                    this.img.loaded = false;
                }
            }
        }
    }
    _drawShape(c, startX, startY, sideLength, sideCountNumerator, sideCountDenominator) {
        let sideCount = sideCountNumerator * sideCountDenominator;
        let decimalSides = sideCountNumerator / sideCountDenominator;
        let interiorAngleDegrees = (180 * (decimalSides - 2)) / decimalSides;
        let interiorAngle = Math.PI - Math.PI * interiorAngleDegrees / 180;
        c.save();
        c.beginPath();
        c.translate(startX, startY);
        c.moveTo(0, 0);
        for (let i = 0; i < sideCount; i++) {
            c.lineTo(sideLength, 0);
            c.translate(sideLength, 0);
            c.rotate(interiorAngle);
        }
        c.fill();
        c.restore();
    }
    draw() {
        let { particles } = this._params;
        let radius;
        if (this.radius_bubble != undefined) {
            radius = this.radius_bubble;
        }
        else {
            radius = this.radius;
        }
        let opacity;
        if (this.opacity_bubble != undefined) {
            opacity = this.opacity_bubble;
        }
        else {
            opacity = this.opacity;
        }
        let color_value;
        if (this.color.rgb) {
            let { r, g, b } = this.color.rgb;
            color_value = `rgba( ${r}, ${g}, ${b}, ${opacity} )`;
        }
        else {
            let { h, s, l } = this.color.hsl;
            color_value = `hsla( ${h}, ${s}, ${l}, ${opacity} )`;
        }
        this._canvasParams.ctx.fillStyle = color_value;
        this._canvasParams.ctx.beginPath();
        switch (this.shape) {
            case 'circle':
                this._canvasParams.ctx.arc(this.x, this.y, radius, 0, Math.PI * 2, false);
                break;
            case 'edge':
                this._canvasParams.ctx.rect(this.x - radius, this.y - radius, radius * 2, radius * 2);
                break;
            case 'triangle':
                this._drawShape(this._canvasParams.ctx, this.x - radius, this.y + radius / 1.66, radius * 2, 3, 2);
                break;
            case 'polygon':
                this._drawShape(this._canvasParams.ctx, this.x - radius / (this._params.particles.shape.polygon.nb_sides / 3.5), this.y - radius / (2.66 / 3.5), radius * 2.66 / (this._params.particles.shape.polygon.nb_sides / 3), this._params.particles.shape.polygon.nb_sides, 1);
                break;
            case 'star':
                this._drawShape(this._canvasParams.ctx, this.x - radius * 2 / (this._params.particles.shape.polygon.nb_sides / 4), this.y - radius / (2 * 2.66 / 3.5), radius * 2 * 2.66 / (this._params.particles.shape.polygon.nb_sides / 3), this._params.particles.shape.polygon.nb_sides, 2);
                break;
            case 'image':
                let draw = (img_obj) => {
                    this._canvasParams.ctx.drawImage(img_obj, this.x - radius, this.y - radius, radius * 2, radius * 2 / this.img.ratio);
                };
                let img_obj;
                if (this._tmpParams.img_type == 'svg') {
                    img_obj = this.img.obj;
                }
                else {
                    img_obj = this._tmpParams.img_obj;
                }
                if (img_obj)
                    draw(img_obj);
                break;
        }
        this._canvasParams.ctx.closePath();
        if (this._params.particles.shape.stroke.width > 0) {
            this._canvasParams.ctx.strokeStyle = this._params.particles.shape.stroke.color;
            this._canvasParams.ctx.lineWidth = this._params.particles.shape.stroke.width;
            this._canvasParams.ctx.stroke();
        }
        this._canvasParams.ctx.fill();
    }
}

class ParticlesManager {
    constructor(_canvasParams, _params, _tmpParams) {
        this._canvasParams = _canvasParams;
        this._params = _params;
        this._tmpParams = _tmpParams;
        this._interaction = new ParticleInteraction();
    }
    particlesCreate() {
        let { color, opacity } = this._params.particles;
        for (let i = 0; i < this._params.particles.number.value; i++) {
            this._params.particles.array.push(new Particle(this._canvasParams, this._params, this._tmpParams, color, opacity.value));
        }
    }
    _particlesUpdate() {
        this._params.particles.array.forEach((particle, i) => {
            if (this._params.particles.move.enable) {
                let ms = this._params.particles.move.speed / 2;
                particle.x += particle.vx * ms;
                particle.y += particle.vy * ms;
            }
            if (this._params.particles.opacity.anim.enable) {
                if (particle.opacity_status == true) {
                    if (particle.opacity >= this._params.particles.opacity.value)
                        particle.opacity_status = false;
                    particle.opacity += particle.vo;
                }
                else {
                    if (particle.opacity <= this._params.particles.opacity.anim.opacity_min)
                        particle.opacity_status = true;
                    particle.opacity -= particle.vo;
                }
                if (particle.opacity < 0)
                    particle.opacity = 0;
            }
            if (this._params.particles.size.anim.enable) {
                if (particle.size_status == true) {
                    if (particle.radius >= this._params.particles.size.value)
                        particle.size_status = false;
                    particle.radius += particle.vs;
                }
                else {
                    if (particle.radius <= this._params.particles.size.anim.size_min)
                        particle.size_status = true;
                    particle.radius -= particle.vs;
                }
                if (particle.radius < 0)
                    particle.radius = 0;
            }
            let new_pos;
            if (this._params.particles.move.out_mode == 'bounce') {
                new_pos = {
                    x_left: particle.radius,
                    x_right: this._canvasParams.width,
                    y_top: particle.radius,
                    y_bottom: this._canvasParams.height
                };
            }
            else {
                new_pos = {
                    x_left: -particle.radius,
                    x_right: this._canvasParams.width + particle.radius,
                    y_top: -particle.radius,
                    y_bottom: this._canvasParams.height + particle.radius
                };
            }
            if (particle.x - particle.radius > this._canvasParams.width) {
                particle.x = new_pos.x_left;
                particle.y = Math.random() * this._canvasParams.height;
            }
            else if (particle.x + particle.radius < 0) {
                particle.x = new_pos.x_right;
                particle.y = Math.random() * this._canvasParams.height;
            }
            if (particle.y - particle.radius > this._canvasParams.height) {
                particle.y = new_pos.y_top;
                particle.x = Math.random() * this._canvasParams.width;
            }
            else if (particle.y + particle.radius < 0) {
                particle.y = new_pos.y_bottom;
                particle.x = Math.random() * this._canvasParams.width;
            }
            switch (this._params.particles.move.out_mode) {
                case 'bounce':
                    if (particle.x + particle.radius > this._canvasParams.width)
                        particle.vx = -particle.vx;
                    else if (particle.x - particle.radius < 0)
                        particle.vx = -particle.vx;
                    if (particle.y + particle.radius > this._canvasParams.height)
                        particle.vy = -particle.vy;
                    else if (particle.y - particle.radius < 0)
                        particle.vy = -particle.vy;
                    break;
            }
            if (isInArray('grab', this._params.interactivity.events.onhover.mode)) {
                this._grabParticle(particle);
            }
            if (isInArray('bubble', this._params.interactivity.events.onhover.mode) ||
                isInArray('bubble', this._params.interactivity.events.onclick.mode)) {
                this._bubbleParticle(particle);
            }
            if (isInArray('repulse', this._params.interactivity.events.onhover.mode) ||
                isInArray('repulse', this._params.interactivity.events.onclick.mode)) {
                this._repulseParticle(particle);
            }
            if (this._params.particles.line_linked.enable || this._params.particles.move.attract.enable) {
                for (let j = i + 1; j < this._params.particles.array.length; j++) {
                    let link = this._params.particles.array[j];
                    if (this._params.particles.line_linked.enable)
                        this._interaction.linkParticles(particle, link, this._params, this._canvasParams);
                    if (this._params.particles.move.attract.enable)
                        this._interaction.attractParticles(particle, link, this._params);
                    if (this._params.particles.move.bounce)
                        this._interaction.bounceParticles(particle, link);
                }
            }
        });
    }
    particlesDraw() {
        this._canvasParams.ctx.clearRect(0, 0, this._canvasParams.width, this._canvasParams.height);
        this._particlesUpdate();
        this._params.particles.array.forEach((particle) => {
            particle.draw();
        });
    }
    particlesEmpty() {
        this._params.particles.array = [];
    }
    removeParticles(nb) {
        this._params.particles.array.splice(0, nb);
        if (!this._params.particles.move.enable) {
            this.particlesDraw();
        }
    }
    pushParticles(nb, pos) {
        this._tmpParams.pushing = true;
        for (let i = 0; i < nb; i++) {
            this._params.particles.array.push(new Particle(this._canvasParams, this._params, this._tmpParams, this._params.particles.color, this._params.particles.opacity.value, {
                x: pos ? pos.pos_x : Math.random() * this._canvasParams.width,
                y: pos ? pos.pos_y : Math.random() * this._canvasParams.height
            }));
            if (i == nb - 1) {
                if (!this._params.particles.move.enable) {
                    this.particlesDraw();
                }
                this._tmpParams.pushing = false;
            }
        }
    }
    _bubbleParticle(particle) {
        if (this._params.interactivity.events.onhover.enable &&
            isInArray('bubble', this._params.interactivity.events.onhover.mode)) {
            let dx_mouse = particle.x - this._params.interactivity.mouse.pos_x;
            let dy_mouse = particle.y - this._params.interactivity.mouse.pos_y;
            let dist_mouse = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse);
            let ratio = 1 - dist_mouse / this._params.interactivity.modes.bubble.distance;
            let init = () => {
                particle.opacity_bubble = particle.opacity;
                particle.radius_bubble = particle.radius;
            };
            if (dist_mouse <= this._params.interactivity.modes.bubble.distance) {
                if (ratio >= 0 && this._params.interactivity.status == 'mousemove') {
                    if (this._params.interactivity.modes.bubble.size != this._params.particles.size.value) {
                        if (this._params.interactivity.modes.bubble.size > this._params.particles.size.value) {
                            let size = particle.radius + (this._params.interactivity.modes.bubble.size * ratio);
                            if (size >= 0) {
                                particle.radius_bubble = size;
                            }
                        }
                        else {
                            let dif = particle.radius - this._params.interactivity.modes.bubble.size;
                            let size = particle.radius - (dif * ratio);
                            if (size > 0) {
                                particle.radius_bubble = size;
                            }
                            else {
                                particle.radius_bubble = 0;
                            }
                        }
                    }
                    if (this._params.interactivity.modes.bubble.opacity != this._params.particles.opacity.value) {
                        if (this._params.interactivity.modes.bubble.opacity > this._params.particles.opacity.value) {
                            let opacity = this._params.interactivity.modes.bubble.opacity * ratio;
                            if (opacity > particle.opacity && opacity <= this._params.interactivity.modes.bubble.opacity) {
                                particle.opacity_bubble = opacity;
                            }
                        }
                        else {
                            let opacity = particle.opacity - (this._params.particles.opacity.value - this._params.interactivity.modes.bubble.opacity) * ratio;
                            if (opacity < particle.opacity && opacity >= this._params.interactivity.modes.bubble.opacity) {
                                particle.opacity_bubble = opacity;
                            }
                        }
                    }
                }
            }
            else {
                init();
            }
            if (this._params.interactivity.status == 'mouseleave') {
                init();
            }
        }
        else if (this._params.interactivity.events.onclick.enable &&
            isInArray('bubble', this._params.interactivity.events.onclick.mode)) {
            if (this._tmpParams.bubble_clicking) {
                let dx_mouse = particle.x - this._params.interactivity.mouse.click_pos_x;
                let dy_mouse = particle.y - this._params.interactivity.mouse.click_pos_y;
                let dist_mouse = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse);
                let time_spent = (new Date().getTime() - this._params.interactivity.mouse.click_time) / 1000;
                if (time_spent > this._params.interactivity.modes.bubble.duration) {
                    this._tmpParams.bubble_duration_end = true;
                }
                if (time_spent > this._params.interactivity.modes.bubble.duration * 2) {
                    this._tmpParams.bubble_clicking = false;
                    this._tmpParams.bubble_duration_end = false;
                }
                let process = (bubble_param, particles_param, p_obj_bubble, p_obj, id) => {
                    if (bubble_param != particles_param) {
                        if (!this._tmpParams.bubble_duration_end) {
                            if (dist_mouse <= this._params.interactivity.modes.bubble.distance) {
                                let obj;
                                if (p_obj_bubble != undefined) {
                                    obj = p_obj_bubble;
                                }
                                else {
                                    obj = p_obj;
                                }
                                if (obj != bubble_param) {
                                    let value = p_obj - (time_spent * (p_obj - bubble_param) / this._params.interactivity.modes.bubble.duration);
                                    if (id == 'size')
                                        particle.radius_bubble = value;
                                    if (id == 'opacity')
                                        particle.opacity_bubble = value;
                                }
                            }
                            else {
                                if (id == 'size')
                                    particle.radius_bubble = undefined;
                                if (id == 'opacity')
                                    particle.opacity_bubble = undefined;
                            }
                        }
                        else {
                            if (p_obj_bubble != undefined) {
                                let value_tmp = p_obj - (time_spent * (p_obj - bubble_param) / this._params.interactivity.modes.bubble.duration);
                                let dif = bubble_param - value_tmp;
                                let value = bubble_param + dif;
                                if (id == 'size')
                                    particle.radius_bubble = value;
                                if (id == 'opacity')
                                    particle.opacity_bubble = value;
                            }
                        }
                    }
                };
                if (this._tmpParams.bubble_clicking) {
                    process(this._params.interactivity.modes.bubble.size, this._params.particles.size.value, particle.radius_bubble, particle.radius, 'size');
                    process(this._params.interactivity.modes.bubble.opacity, this._params.particles.opacity.value, particle.opacity_bubble, particle.opacity, 'opacity');
                }
            }
        }
    }
    _repulseParticle(particle) {
        if (this._params.interactivity.events.onhover.enable &&
            isInArray('repulse', this._params.interactivity.events.onhover.mode) &&
            this._params.interactivity.status == 'mousemove') {
            let dx_mouse = particle.x - this._params.interactivity.mouse.pos_x;
            let dy_mouse = particle.y - this._params.interactivity.mouse.pos_y;
            let dist_mouse = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse);
            let normVec = { x: dx_mouse / dist_mouse, y: dy_mouse / dist_mouse };
            let repulseRadius = this._params.interactivity.modes.repulse.distance;
            let velocity = 100;
            let repulseFactor = clamp((1 / repulseRadius) * (-1 * Math.pow(dist_mouse / repulseRadius, 2) + 1) * repulseRadius * velocity, 0, 50);
            let pos = {
                x: particle.x + normVec.x * repulseFactor,
                y: particle.y + normVec.y * repulseFactor
            };
            if (this._params.particles.move.out_mode == 'bounce') {
                if (pos.x - particle.radius > 0 && pos.x + particle.radius < this._canvasParams.width)
                    particle.x = pos.x;
                if (pos.y - particle.radius > 0 && pos.y + particle.radius < this._canvasParams.height)
                    particle.y = pos.y;
            }
            else {
                particle.x = pos.x;
                particle.y = pos.y;
            }
        }
        else if (this._params.interactivity.events.onclick.enable &&
            isInArray('repulse', this._params.interactivity.events.onclick.mode)) {
            if (!this._tmpParams.repulse_finish) {
                this._tmpParams.repulse_count++;
                if (this._tmpParams.repulse_count == this._params.particles.array.length)
                    this._tmpParams.repulse_finish = true;
            }
            if (this._tmpParams.repulse_clicking) {
                let repulseRadius = Math.pow(this._params.interactivity.modes.repulse.distance / 6, 3);
                let dx = this._params.interactivity.mouse.click_pos_x - particle.x;
                let dy = this._params.interactivity.mouse.click_pos_y - particle.y;
                let d = dx * dx + dy * dy;
                let force = -repulseRadius / d * 1;
                let process = () => {
                    let f = Math.atan2(dy, dx);
                    particle.vx = force * Math.cos(f);
                    particle.vy = force * Math.sin(f);
                    if (this._params.particles.move.out_mode == 'bounce') {
                        let pos = {
                            x: particle.x + particle.vx,
                            y: particle.y + particle.vy
                        };
                        if (pos.x + particle.radius > this._canvasParams.width)
                            particle.vx = -particle.vx;
                        else if (pos.x - particle.radius < 0)
                            particle.vx = -particle.vx;
                        if (pos.y + particle.radius > this._canvasParams.height)
                            particle.vy = -particle.vy;
                        else if (pos.y - particle.radius < 0)
                            particle.vy = -particle.vy;
                    }
                };
                if (d <= repulseRadius) {
                    process();
                }
            }
            else {
                if (this._tmpParams.repulse_clicking == false) {
                    particle.vx = particle.vx_i;
                    particle.vy = particle.vy_i;
                }
            }
        }
    }
    _grabParticle(particle) {
        let { interactivity, particles } = this._params;
        if (interactivity.events.onhover.enable &&
            interactivity.status == 'mousemove') {
            let dx_mouse = particle.x - interactivity.mouse.pos_x;
            let dy_mouse = particle.y - interactivity.mouse.pos_y;
            let dist_mouse = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse);
            if (dist_mouse <= interactivity.modes.grab.distance) {
                let { grab } = interactivity.modes;
                let opacity_line = grab.line_linked.opacity - (dist_mouse / (1 / grab.line_linked.opacity)) / grab.distance;
                if (opacity_line > 0) {
                    let color_line = particles.line_linked.color_rgb_line;
                    let { r, g, b } = color_line;
                    this._canvasParams.ctx.strokeStyle = `rgba( ${r}, ${g}, ${b}, ${opacity_line} )`;
                    this._canvasParams.ctx.lineWidth = particles.line_linked.width;
                    this._canvasParams.ctx.beginPath();
                    this._canvasParams.ctx.moveTo(particle.x, particle.y);
                    this._canvasParams.ctx.lineTo(interactivity.mouse.pos_x, interactivity.mouse.pos_y);
                    this._canvasParams.ctx.stroke();
                    this._canvasParams.ctx.closePath();
                }
            }
        }
    }
}

class CanvasManager {
    constructor(_canvasParams, _params, _tmpParams) {
        this._canvasParams = _canvasParams;
        this._params = _params;
        this._tmpParams = _tmpParams;
        this._onWindowResize = this._onWindowResize.bind(this);
        this._retinaInit();
        this._canvasSize();
        this.particlesManager = new ParticlesManager(this._canvasParams, this._params, this._tmpParams);
        this.particlesManager.particlesCreate();
        this._densityAutoParticles();
        let { particles } = this._params;
        particles.line_linked.color_rgb_line = hexToRgb(particles.line_linked.color);
    }
    cancelAnimation() {
        if (!this._tmpParams.drawAnimFrame) {
            return;
        }
        cancelAnimationFrame(this._tmpParams.drawAnimFrame);
        this._tmpParams.drawAnimFrame = null;
    }
    draw() {
        let { particles } = this._params;
        if (particles.shape.type == 'image') {
            if (this._tmpParams.img_type == 'svg') {
                if (this._tmpParams.count_svg >= particles.number.value) {
                    this.particlesManager.particlesDraw();
                    if (!particles.move.enable) {
                        cancelAnimationFrame(this._tmpParams.drawAnimFrame);
                    }
                    else {
                        this._tmpParams.drawAnimFrame = requestAnimationFrame(this.draw.bind(this));
                    }
                }
                else {
                    if (!this._tmpParams.img_error) {
                        this._tmpParams.drawAnimFrame = requestAnimationFrame(this.draw.bind(this));
                    }
                }
            }
            else {
                if (this._tmpParams.img_obj != undefined) {
                    this.particlesManager.particlesDraw();
                    if (!particles.move.enable) {
                        cancelAnimationFrame(this._tmpParams.drawAnimFrame);
                    }
                    else {
                        this._tmpParams.drawAnimFrame = requestAnimationFrame(this.draw.bind(this));
                    }
                }
                else {
                    if (!this._tmpParams.img_error) {
                        this._tmpParams.drawAnimFrame = requestAnimationFrame(this.draw.bind(this));
                    }
                }
            }
        }
        else {
            this.particlesManager.particlesDraw();
            if (!particles.move.enable) {
                cancelAnimationFrame(this._tmpParams.drawAnimFrame);
            }
            else {
                this._tmpParams.drawAnimFrame = requestAnimationFrame(this.draw.bind(this));
            }
        }
    }
    _densityAutoParticles() {
        let { particles } = this._params;
        if (particles.number.density.enable) {
            let area = this._canvasParams.el.width * this._canvasParams.el.height / 1000;
            if (this._tmpParams.retina) {
                area = area / (this._canvasParams.pxratio * 2);
            }
            let nb_particles = area * particles.number.value / particles.number.density.value_area;
            let missing_particles = particles.array.length - nb_particles;
            if (missing_particles < 0) {
                this.particlesManager.pushParticles(Math.abs(missing_particles));
            }
            else {
                this.particlesManager.removeParticles(missing_particles);
            }
        }
    }
    _retinaInit() {
        if (this._params.retina_detect && window.devicePixelRatio > 1) {
            this._canvasParams.pxratio = window.devicePixelRatio;
            this._tmpParams.retina = true;
            this._canvasParams.width = this._canvasParams.el.offsetWidth * this._canvasParams.pxratio;
            this._canvasParams.height = this._canvasParams.el.offsetHeight * this._canvasParams.pxratio;
            this._params.particles.size.value = this._tmpParams.obj.size_value * this._canvasParams.pxratio;
            this._params.particles.size.anim.speed = this._tmpParams.obj.size_anim_speed * this._canvasParams.pxratio;
            this._params.particles.move.speed = this._tmpParams.obj.move_speed * this._canvasParams.pxratio;
            this._params.particles.line_linked.distance = this._tmpParams.obj.line_linked_distance * this._canvasParams.pxratio;
            this._params.interactivity.modes.grab.distance = this._tmpParams.obj.mode_grab_distance * this._canvasParams.pxratio;
            this._params.interactivity.modes.bubble.distance = this._tmpParams.obj.mode_bubble_distance * this._canvasParams.pxratio;
            this._params.particles.line_linked.width = this._tmpParams.obj.line_linked_width * this._canvasParams.pxratio;
            this._params.interactivity.modes.bubble.size = this._tmpParams.obj.mode_bubble_size * this._canvasParams.pxratio;
            this._params.interactivity.modes.repulse.distance = this._tmpParams.obj.mode_repulse_distance * this._canvasParams.pxratio;
        }
        else {
            this._canvasParams.pxratio = 1;
            this._tmpParams.retina = false;
        }
    }
    _canvasClear() {
        this._canvasParams.ctx.clearRect(0, 0, this._canvasParams.width, this._canvasParams.height);
    }
    _canvasPaint() {
        this._canvasParams.ctx.fillRect(0, 0, this._canvasParams.width, this._canvasParams.height);
    }
    _canvasSize() {
        this._canvasParams.el.width = this._canvasParams.width;
        this._canvasParams.el.height = this._canvasParams.height;
        if (this._params && this._params.interactivity.events.resize) {
            window.addEventListener('resize', this._onWindowResize);
        }
    }
    _onWindowResize() {
        this._canvasParams.width = this._canvasParams.el.offsetWidth;
        this._canvasParams.height = this._canvasParams.el.offsetHeight;
        if (this._tmpParams.retina) {
            this._canvasParams.width *= this._canvasParams.pxratio;
            this._canvasParams.height *= this._canvasParams.pxratio;
        }
        this._canvasParams.el.width = this._canvasParams.width;
        this._canvasParams.el.height = this._canvasParams.height;
        if (!this._params.particles.move.enable) {
            this.particlesManager.particlesEmpty();
            this.particlesManager.particlesCreate();
            this.particlesManager.particlesDraw();
            this._densityAutoParticles();
        }
        this._densityAutoParticles();
    }
}

let ParticlesDirective = class ParticlesDirective {
    constructor(el) {
        this.el = el;
        this._tmpParams = {};
    }
    set params(value) {
        let defaultParams = getDefaultParams();
        this._params = deepExtend(defaultParams, value);
    }
    ngOnDestroy() {
        if (!this._canvasManager) {
            return;
        }
        this._canvasManager.cancelAnimation();
    }
    ngAfterViewInit() {
        this._canvasParams = {
            el: this.el.nativeElement,
            ctx: this.el.nativeElement.getContext('2d'),
            width: this.el.nativeElement.offsetWidth,
            height: this.el.nativeElement.offsetHeight
        };
        this._tmpParams.obj = {
            size_value: this._params.particles.size.value,
            size_anim_speed: this._params.particles.size.anim.speed,
            move_speed: this._params.particles.move.speed,
            line_linked_distance: this._params.particles.line_linked.distance,
            line_linked_width: this._params.particles.line_linked.width,
            mode_grab_distance: this._params.interactivity.modes.grab.distance,
            mode_bubble_distance: this._params.interactivity.modes.bubble.distance,
            mode_bubble_size: this._params.interactivity.modes.bubble.size,
            mode_repulse_distance: this._params.interactivity.modes.repulse.distance
        };
        this._params.interactivity.el = (this._params.interactivity.detect_on == 'window') ? window : this._canvasParams.el;
        if (isInArray('image', this._params.particles.shape.type)) {
            this._tmpParams.img_type = this._params.particles.shape.image.src.substr(this._params.particles.shape.image.src.length - 3);
            loadImg(this._params, this._tmpParams);
        }
        this._canvasManager = new CanvasManager(this._canvasParams, this._params, this._tmpParams);
        this._canvasManager.draw();
    }
    /**
     * Mouse move event
     * @param event
     */
    onMouseMove(event) {
        let { interactivity } = this._params;
        if (interactivity.events.onhover.enable ||
            interactivity.events.onclick.enable) {
            let pos;
            if (interactivity.el == window) {
                pos = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
            else {
                pos = {
                    x: event.offsetX || event.clientX,
                    y: event.offsetY || event.clientY
                };
            }
            interactivity.mouse.pos_x = pos.x;
            interactivity.mouse.pos_y = pos.y;
            if (this._tmpParams.retina) {
                interactivity.mouse.pos_x *= this._canvasParams.pxratio;
                interactivity.mouse.pos_y *= this._canvasParams.pxratio;
            }
            interactivity.status = 'mousemove';
        }
    }
    /**
     * Mouse leave event
     */
    onMouseLeave() {
        let { interactivity } = this._params;
        if (interactivity.events.onhover.enable ||
            interactivity.events.onclick.enable) {
            interactivity.mouse.pos_x = null;
            interactivity.mouse.pos_y = null;
            interactivity.status = 'mouseleave';
        }
    }
    /**
     * Click event
     */
    onClick() {
        let { interactivity, particles } = this._params;
        if (interactivity.events.onclick.enable) {
            interactivity.mouse.click_pos_x = interactivity.mouse.pos_x;
            interactivity.mouse.click_pos_y = interactivity.mouse.pos_y;
            interactivity.mouse.click_time = new Date().getTime();
            switch (interactivity.events.onclick.mode) {
                case 'push':
                    if (particles.move.enable) {
                        this._canvasManager.particlesManager.pushParticles(interactivity.modes.push.particles_nb, interactivity.mouse);
                    }
                    else {
                        if (interactivity.modes.push.particles_nb == 1) {
                            this._canvasManager.particlesManager.pushParticles(interactivity.modes.push.particles_nb, interactivity.mouse);
                        }
                        else if (interactivity.modes.push.particles_nb > 1) {
                            this._canvasManager.particlesManager.pushParticles(interactivity.modes.push.particles_nb);
                        }
                    }
                    break;
                case 'remove':
                    this._canvasManager.particlesManager.removeParticles(interactivity.modes.remove.particles_nb);
                    break;
                case 'bubble':
                    this._tmpParams.bubble_clicking = true;
                    break;
                case 'repulse':
                    this._tmpParams.repulse_clicking = true;
                    this._tmpParams.repulse_count = 0;
                    this._tmpParams.repulse_finish = false;
                    setTimeout(() => {
                        this._tmpParams.repulse_clicking = false;
                    }, interactivity.modes.repulse.duration * 1000);
                    break;
            }
        }
    }
};
ParticlesDirective.ɵfac = function ParticlesDirective_Factory(t) { return new (t || ParticlesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ParticlesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ParticlesDirective, selectors: [["", "d-particles", ""]], hostBindings: function ParticlesDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousemove", function ParticlesDirective_mousemove_HostBindingHandler($event) { return ctx.onMouseMove($event); })("mouseleave", function ParticlesDirective_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); })("click", function ParticlesDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } }, inputs: { params: "params" } });
ParticlesDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], ParticlesDirective.prototype, "params", null);
__decorate([
    HostListener('mousemove', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], ParticlesDirective.prototype, "onMouseMove", null);
__decorate([
    HostListener('mouseleave'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ParticlesDirective.prototype, "onMouseLeave", null);
__decorate([
    HostListener('click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ParticlesDirective.prototype, "onClick", null);
ParticlesDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], ParticlesDirective);

let ParticlesModule = class ParticlesModule {
};
ParticlesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ParticlesModule });
ParticlesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ParticlesModule_Factory(t) { return new (t || ParticlesModule)(); }, imports: [[
            CommonModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ParticlesComponent, [{
        type: Component,
        args: [{
                selector: 'particles',
                template: `
        <div [ngStyle]="style" class="particles-container">
            <canvas d-particles [params]="params" [style.width.%]="width" [style.height.%]="height"></canvas>
        </div>
    `
            }]
    }], function () { return []; }, { width: [{
            type: Input
        }], height: [{
            type: Input
        }], style: [{
            type: Input
        }], params: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ParticlesDirective, [{
        type: Directive,
        args: [{
                selector: '[d-particles]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { params: [{
            type: Input
        }], 
    /**
     * Mouse move event
     * @param event
     */
    onMouseMove: [{
            type: HostListener,
            args: ['mousemove', ['$event']]
        }], 
    /**
     * Mouse leave event
     */
    onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], 
    /**
     * Click event
     */
    onClick: [{
            type: HostListener,
            args: ['click']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ParticlesModule, { declarations: function () { return [ParticlesComponent, ParticlesDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ParticlesComponent, ParticlesDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ParticlesModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    ParticlesComponent,
                    ParticlesDirective
                ],
                exports: [
                    ParticlesComponent,
                    ParticlesDirective
                ]
            }]
    }], null, null); })();

/*
 * Public API Surface of ngx-export-as
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CanvasManager, Particle, ParticleInteraction, ParticlesComponent, ParticlesDirective, ParticlesManager, ParticlesModule, clamp, createSvgImg, deepExtend, getColor, getDefaultParams, hexToRgb, isInArray, loadImg };

//# sourceMappingURL=ngx-particle.js.map