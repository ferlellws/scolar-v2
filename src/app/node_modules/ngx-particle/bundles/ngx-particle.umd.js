(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-particle', ['exports', '@angular/core', '@angular/common'], factory) :
    (global = global || self, factory(global['ngx-particle'] = {}, global.ng.core, global.ng.common));
}(this, (function (exports, core, common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var ParticlesComponent = /** @class */ (function () {
        function ParticlesComponent() {
            this.width = 100;
            this.height = 100;
            this.style = {};
        }
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], ParticlesComponent.prototype, "width", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], ParticlesComponent.prototype, "height", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], ParticlesComponent.prototype, "params", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], ParticlesComponent.prototype, "style", void 0);
        ParticlesComponent = __decorate([
            core.Component({
                selector: 'particles',
                template: "\n        <div [ngStyle]=\"style\" class=\"particles-container\">\n            <canvas d-particles [params]=\"params\" [style.width.%]=\"width\" [style.height.%]=\"height\"></canvas>\n        </div>\n    "
            }),
            __metadata("design:paramtypes", [])
        ], ParticlesComponent);
        return ParticlesComponent;
    }());

    var hexToRgb = function (hex) {
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function (m, r, g, b) {
            return r + r + g + g + b + b;
        });
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    };
    var clamp = function (number, min, max) {
        return Math.min(Math.max(number, min), max);
    };
    var isInArray = function (value, array) {
        return array.indexOf(value) > -1;
    };
    var deepExtend = function (destination, source) {
        for (var property in source) {
            if (source[property] &&
                source[property].constructor &&
                source[property].constructor === Object) {
                destination[property] = destination[property] || {};
                deepExtend(destination[property], source[property]);
            }
            else {
                destination[property] = source[property];
            }
        }
        return destination;
    };
    var getColor = function (colorObject) {
        var color = {};
        if (typeof (colorObject) == 'object') {
            if (colorObject instanceof Array) {
                var selectedColor = colorObject[Math.floor(Math.random() * colorObject.length)];
                color.rgb = hexToRgb(selectedColor);
            }
            else {
                var r = colorObject.r, g = colorObject.g, b = colorObject.b;
                if (r !== undefined && g !== undefined && b !== undefined) {
                    color.rgb = { r: r, g: g, b: b };
                }
                else {
                    var h = colorObject.h, s = colorObject.s, l = colorObject.l;
                    if (h !== undefined && g !== undefined && b !== undefined) {
                        color.hsl = { h: h, s: s, l: l };
                    }
                }
            }
        }
        else if (colorObject == 'random') {
            color.rgb = {
                r: (Math.floor(Math.random() * 255) + 1),
                g: (Math.floor(Math.random() * 255) + 1),
                b: (Math.floor(Math.random() * 255) + 1)
            };
        }
        else if (typeof (colorObject) == 'string') {
            color.rgb = hexToRgb(colorObject);
        }
        return color;
    };
    var getDefaultParams = function () {
        return {
            particles: {
                number: {
                    value: 100,
                    density: {
                        enable: true,
                        value_area: 800
                    }
                },
                color: {
                    value: '#FFF'
                },
                shape: {
                    type: 'circle',
                    stroke: {
                        width: 0,
                        color: '#000000'
                    },
                    polygon: {
                        nb_sides: 5
                    },
                    image: {
                        src: '',
                        width: 100,
                        height: 100
                    }
                },
                opacity: {
                    value: 0.5,
                    random: false,
                    anim: {
                        enable: true,
                        speed: 1,
                        opacity_min: 0.1,
                        sync: false
                    }
                },
                size: {
                    value: 3,
                    random: true,
                    anim: {
                        enable: false,
                        speed: 40,
                        size_min: 0,
                        sync: false
                    }
                },
                line_linked: {
                    enable: true,
                    distance: 150,
                    color: '#FFF',
                    opacity: 0.6,
                    width: 1,
                    shadow: {
                        enable: false,
                        blur: 5,
                        color: 'lime'
                    }
                },
                move: {
                    enable: true,
                    speed: 3,
                    direction: 'none',
                    random: false,
                    straight: false,
                    out_mode: 'out',
                    bounce: true,
                    attract: {
                        enable: false,
                        rotateX: 3000,
                        rotateY: 3000
                    }
                },
                array: []
            },
            interactivity: {
                detect_on: 'canvas',
                events: {
                    onhover: {
                        enable: true,
                        mode: 'grab'
                    },
                    onclick: {
                        enable: true,
                        mode: 'push'
                    },
                    resize: true
                },
                modes: {
                    grab: {
                        distance: 200,
                        line_linked: {
                            opacity: 1
                        }
                    },
                    bubble: {
                        distance: 200,
                        size: 80,
                        duration: 0.4
                    },
                    repulse: {
                        distance: 200,
                        duration: 0.4
                    },
                    push: {
                        particles_nb: 4
                    },
                    remove: {
                        particles_nb: 2
                    }
                },
                mouse: {}
            },
            retina_detect: true
        };
    };
    function loadImg(params, tmp) {
        var particles = params.particles;
        tmp.img_error = undefined;
        if (particles.shape.type == 'image' && particles.shape.image.src != '') {
            if (tmp.img_type == 'svg') {
                var xhr_1 = new XMLHttpRequest();
                xhr_1.open('GET', particles.shape.image.src);
                xhr_1.onreadystatechange = function (data) {
                    if (xhr_1.readyState == 4) {
                        if (xhr_1.status == 200) {
                            tmp.source_svg = data.currentTarget.response;
                            if (tmp.source_svg == undefined) {
                                var check = void 0;
                                tmp.checkAnimFrame = requestAnimationFrame(check);
                            }
                        }
                        else {
                            tmp.img_error = true;
                            throw "Error : image not found";
                        }
                    }
                };
                xhr_1.send();
            }
            else {
                var img_1 = new Image();
                img_1.addEventListener('load', function () {
                    tmp.img_obj = img_1;
                    cancelAnimationFrame(tmp.checkAnimFrame);
                });
                img_1.src = particles.shape.image.src;
            }
        }
        else {
            tmp.img_error = true;
            throw "Error : no image.src";
        }
    }
    function createSvgImg(particle, tmp) {
        var svgXml = tmp.source_svg;
        var rgbHex = /#([0-9A-F]{3,6})/gi;
        var coloredSvgXml = svgXml.replace(rgbHex, function (m, r, g, b) {
            var color_value;
            if (particle.color.rgb) {
                var _a = particle.color.rgb, r_1 = _a.r, g_1 = _a.g, b_1 = _a.b;
                color_value = "rgba( " + r_1 + ", " + g_1 + ", " + b_1 + ", " + particle.opacity + " )";
            }
            else {
                var _b = particle.color.hsl, h = _b.h, s = _b.s, l = _b.l;
                color_value = "rgba( " + h + ", " + s + ", " + l + ", " + particle.opacity + " )";
            }
            return color_value;
        });
        var svg = new Blob([coloredSvgXml], {
            type: 'image/svg+xml;charset=utf-8'
        });
        var DOMURL = window.URL || window;
        var url = DOMURL.createObjectURL(svg);
        var img = new Image();
        img.addEventListener('load', function () {
            particle.img.obj = img;
            particle.img.loaded = true;
            DOMURL.revokeObjectURL(url);
            tmp.count_svg++;
        });
        img.src = url;
    }

    var ParticleInteraction = /** @class */ (function () {
        function ParticleInteraction() {
        }
        ParticleInteraction.prototype.linkParticles = function (p1, p2, params, canvasParams) {
            var dx = p1.x - p2.x;
            var dy = p1.y - p2.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            var line_linked = params.particles.line_linked;
            if (dist <= params.particles.line_linked.distance) {
                var opacity_line = params.particles.line_linked.opacity - (dist / (1 / params.particles.line_linked.opacity)) / params.particles.line_linked.distance;
                if (opacity_line > 0) {
                    var color_line = params.particles.line_linked.color_rgb_line;
                    var r = color_line.r, g = color_line.g, b = color_line.b;
                    canvasParams.ctx.save();
                    canvasParams.ctx.strokeStyle = "rgba( " + r + ", " + g + ", " + b + ", " + opacity_line + " )";
                    canvasParams.ctx.lineWidth = params.particles.line_linked.width;
                    canvasParams.ctx.beginPath();
                    if (line_linked.shadow.enable) {
                        canvasParams.ctx.shadowBlur = line_linked.shadow.blur;
                        canvasParams.ctx.shadowColor = line_linked.shadow.color;
                    }
                    canvasParams.ctx.moveTo(p1.x, p1.y);
                    canvasParams.ctx.lineTo(p2.x, p2.y);
                    canvasParams.ctx.stroke();
                    canvasParams.ctx.closePath();
                    canvasParams.ctx.restore();
                }
            }
        };
        ParticleInteraction.prototype.attractParticles = function (p1, p2, params) {
            var dx = p1.x - p2.x;
            var dy = p1.y - p2.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            if (dist <= params.particles.line_linked.distance) {
                var ax = dx / (params.particles.move.attract.rotateX * 1000);
                var ay = dy / (params.particles.move.attract.rotateY * 1000);
                p1.vx -= ax;
                p1.vy -= ay;
                p2.vx += ax;
                p2.vy += ay;
            }
        };
        ParticleInteraction.prototype.bounceParticles = function (p1, p2) {
            var dx = p1.x - p2.x;
            var dy = p1.y - p2.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            var dist_p = p1.radius + p2.radius;
            if (dist <= dist_p) {
                p1.vx = -p1.vx;
                p1.vy = -p1.vy;
                p2.vx = -p2.vx;
                p2.vy = -p2.vy;
            }
        };
        return ParticleInteraction;
    }());

    var Particle = /** @class */ (function () {
        function Particle(_canvasParams, _params, _tmpParams, color, opacity, position) {
            this._canvasParams = _canvasParams;
            this._params = _params;
            this._tmpParams = _tmpParams;
            this._setupSize();
            this._setupPosition(position);
            this._setupColor(color);
            this._setupOpacity();
            this._setupAnimation();
        }
        Particle.prototype._setupSize = function () {
            this.radius = (this._params.particles.size.random ? Math.random() : 1) * this._params.particles.size.value;
            if (this._params.particles.size.anim.enable) {
                this.size_status = false;
                this.vs = this._params.particles.size.anim.speed / 100;
                if (!this._params.particles.size.anim.sync)
                    this.vs = this.vs * Math.random();
            }
        };
        Particle.prototype._setupPosition = function (position) {
            this.x = position ? position.x : Math.random() * this._canvasParams.width;
            this.y = position ? position.y : Math.random() * this._canvasParams.height;
            if (this.x > this._canvasParams.width - this.radius * 2) {
                this.x = this.x - this.radius;
            }
            else if (this.x < this.radius * 2) {
                this.x = this.x + this.radius;
            }
            if (this.y > this._canvasParams.height - this.radius * 2) {
                this.y = this.y - this.radius;
            }
            else if (this.y < this.radius * 2) {
                this.y = this.y + this.radius;
            }
            if (this._params.particles.move.bounce) {
                this._checkOverlap(this, position);
            }
        };
        Particle.prototype._checkOverlap = function (p1, position) {
            var _this = this;
            var particles = this._params.particles;
            particles.array.forEach(function (particle) {
                var p2 = particle;
                var dx = p1.x - p2.x;
                var dy = p1.y - p2.y;
                var dist = Math.sqrt(dx * dx + dy * dy);
                if (dist <= p1.radius + p2.radius) {
                    p1.x = position ? position.x : Math.random() * _this._canvasParams.width;
                    p1.y = position ? position.y : Math.random() * _this._canvasParams.height;
                    _this._checkOverlap(p1);
                }
            });
        };
        Particle.prototype._setupColor = function (color) {
            this.color = getColor(color.value);
        };
        Particle.prototype._setupOpacity = function () {
            this.opacity = (this._params.particles.opacity.random ? Math.random() : 1) * this._params.particles.opacity.value;
            if (this._params.particles.opacity.anim.enable) {
                this.opacity_status = false;
                this.vo = this._params.particles.opacity.anim.speed / 100;
                if (!this._params.particles.opacity.anim.sync) {
                    this.vo = this.vo * Math.random();
                }
            }
        };
        Particle.prototype._setupAnimation = function () {
            var velbase = null;
            switch (this._params.particles.move.direction) {
                case 'top':
                    velbase = { x: 0, y: -1 };
                    break;
                case 'top-right':
                    velbase = { x: 0.5, y: -0.5 };
                    break;
                case 'right':
                    velbase = { x: 1, y: 0 };
                    break;
                case 'bottom-right':
                    velbase = { x: 0.5, y: 0.5 };
                    break;
                case 'bottom':
                    velbase = { x: 0, y: 1 };
                    break;
                case 'bottom-left':
                    velbase = { x: -0.5, y: 1 };
                    break;
                case 'left':
                    velbase = { x: -1, y: 0 };
                    break;
                case 'top-left':
                    velbase = { x: -0.5, y: -0.5 };
                    break;
                default:
                    velbase = { x: 0, y: 0 };
                    break;
            }
            if (this._params.particles.move.straight) {
                this.vx = velbase.x;
                this.vy = velbase.y;
                if (this._params.particles.move.random) {
                    this.vx = this.vx * (Math.random());
                    this.vy = this.vy * (Math.random());
                }
            }
            else {
                this.vx = velbase.x + Math.random() - 0.5;
                this.vy = velbase.y + Math.random() - 0.5;
            }
            this.vx_i = this.vx;
            this.vy_i = this.vy;
            var shape_type = this._params.particles.shape.type;
            if (typeof (shape_type) == 'object') {
                if (shape_type instanceof Array) {
                    var shape_selected = shape_type[Math.floor(Math.random() * shape_type.length)];
                    this.shape = shape_selected;
                }
            }
            else {
                this.shape = shape_type;
            }
            if (this.shape == 'image') {
                var sh = this._params.particles.shape;
                this.img = {
                    src: sh.image.src,
                    ratio: sh.image.width / sh.image.height
                };
                if (!this.img.ratio)
                    this.img.ratio = 1;
                if (this._tmpParams.img_type == 'svg' && this._tmpParams.source_svg != undefined) {
                    createSvgImg(this, this._tmpParams);
                    if (this._tmpParams.pushing) {
                        this.img.loaded = false;
                    }
                }
            }
        };
        Particle.prototype._drawShape = function (c, startX, startY, sideLength, sideCountNumerator, sideCountDenominator) {
            var sideCount = sideCountNumerator * sideCountDenominator;
            var decimalSides = sideCountNumerator / sideCountDenominator;
            var interiorAngleDegrees = (180 * (decimalSides - 2)) / decimalSides;
            var interiorAngle = Math.PI - Math.PI * interiorAngleDegrees / 180;
            c.save();
            c.beginPath();
            c.translate(startX, startY);
            c.moveTo(0, 0);
            for (var i = 0; i < sideCount; i++) {
                c.lineTo(sideLength, 0);
                c.translate(sideLength, 0);
                c.rotate(interiorAngle);
            }
            c.fill();
            c.restore();
        };
        Particle.prototype.draw = function () {
            var _this = this;
            var particles = this._params.particles;
            var radius;
            if (this.radius_bubble != undefined) {
                radius = this.radius_bubble;
            }
            else {
                radius = this.radius;
            }
            var opacity;
            if (this.opacity_bubble != undefined) {
                opacity = this.opacity_bubble;
            }
            else {
                opacity = this.opacity;
            }
            var color_value;
            if (this.color.rgb) {
                var _a = this.color.rgb, r = _a.r, g = _a.g, b = _a.b;
                color_value = "rgba( " + r + ", " + g + ", " + b + ", " + opacity + " )";
            }
            else {
                var _b = this.color.hsl, h = _b.h, s = _b.s, l = _b.l;
                color_value = "hsla( " + h + ", " + s + ", " + l + ", " + opacity + " )";
            }
            this._canvasParams.ctx.fillStyle = color_value;
            this._canvasParams.ctx.beginPath();
            switch (this.shape) {
                case 'circle':
                    this._canvasParams.ctx.arc(this.x, this.y, radius, 0, Math.PI * 2, false);
                    break;
                case 'edge':
                    this._canvasParams.ctx.rect(this.x - radius, this.y - radius, radius * 2, radius * 2);
                    break;
                case 'triangle':
                    this._drawShape(this._canvasParams.ctx, this.x - radius, this.y + radius / 1.66, radius * 2, 3, 2);
                    break;
                case 'polygon':
                    this._drawShape(this._canvasParams.ctx, this.x - radius / (this._params.particles.shape.polygon.nb_sides / 3.5), this.y - radius / (2.66 / 3.5), radius * 2.66 / (this._params.particles.shape.polygon.nb_sides / 3), this._params.particles.shape.polygon.nb_sides, 1);
                    break;
                case 'star':
                    this._drawShape(this._canvasParams.ctx, this.x - radius * 2 / (this._params.particles.shape.polygon.nb_sides / 4), this.y - radius / (2 * 2.66 / 3.5), radius * 2 * 2.66 / (this._params.particles.shape.polygon.nb_sides / 3), this._params.particles.shape.polygon.nb_sides, 2);
                    break;
                case 'image':
                    var draw = function (img_obj) {
                        _this._canvasParams.ctx.drawImage(img_obj, _this.x - radius, _this.y - radius, radius * 2, radius * 2 / _this.img.ratio);
                    };
                    var img_obj = void 0;
                    if (this._tmpParams.img_type == 'svg') {
                        img_obj = this.img.obj;
                    }
                    else {
                        img_obj = this._tmpParams.img_obj;
                    }
                    if (img_obj)
                        draw(img_obj);
                    break;
            }
            this._canvasParams.ctx.closePath();
            if (this._params.particles.shape.stroke.width > 0) {
                this._canvasParams.ctx.strokeStyle = this._params.particles.shape.stroke.color;
                this._canvasParams.ctx.lineWidth = this._params.particles.shape.stroke.width;
                this._canvasParams.ctx.stroke();
            }
            this._canvasParams.ctx.fill();
        };
        return Particle;
    }());

    var ParticlesManager = /** @class */ (function () {
        function ParticlesManager(_canvasParams, _params, _tmpParams) {
            this._canvasParams = _canvasParams;
            this._params = _params;
            this._tmpParams = _tmpParams;
            this._interaction = new ParticleInteraction();
        }
        ParticlesManager.prototype.particlesCreate = function () {
            var _a = this._params.particles, color = _a.color, opacity = _a.opacity;
            for (var i = 0; i < this._params.particles.number.value; i++) {
                this._params.particles.array.push(new Particle(this._canvasParams, this._params, this._tmpParams, color, opacity.value));
            }
        };
        ParticlesManager.prototype._particlesUpdate = function () {
            var _this = this;
            this._params.particles.array.forEach(function (particle, i) {
                if (_this._params.particles.move.enable) {
                    var ms = _this._params.particles.move.speed / 2;
                    particle.x += particle.vx * ms;
                    particle.y += particle.vy * ms;
                }
                if (_this._params.particles.opacity.anim.enable) {
                    if (particle.opacity_status == true) {
                        if (particle.opacity >= _this._params.particles.opacity.value)
                            particle.opacity_status = false;
                        particle.opacity += particle.vo;
                    }
                    else {
                        if (particle.opacity <= _this._params.particles.opacity.anim.opacity_min)
                            particle.opacity_status = true;
                        particle.opacity -= particle.vo;
                    }
                    if (particle.opacity < 0)
                        particle.opacity = 0;
                }
                if (_this._params.particles.size.anim.enable) {
                    if (particle.size_status == true) {
                        if (particle.radius >= _this._params.particles.size.value)
                            particle.size_status = false;
                        particle.radius += particle.vs;
                    }
                    else {
                        if (particle.radius <= _this._params.particles.size.anim.size_min)
                            particle.size_status = true;
                        particle.radius -= particle.vs;
                    }
                    if (particle.radius < 0)
                        particle.radius = 0;
                }
                var new_pos;
                if (_this._params.particles.move.out_mode == 'bounce') {
                    new_pos = {
                        x_left: particle.radius,
                        x_right: _this._canvasParams.width,
                        y_top: particle.radius,
                        y_bottom: _this._canvasParams.height
                    };
                }
                else {
                    new_pos = {
                        x_left: -particle.radius,
                        x_right: _this._canvasParams.width + particle.radius,
                        y_top: -particle.radius,
                        y_bottom: _this._canvasParams.height + particle.radius
                    };
                }
                if (particle.x - particle.radius > _this._canvasParams.width) {
                    particle.x = new_pos.x_left;
                    particle.y = Math.random() * _this._canvasParams.height;
                }
                else if (particle.x + particle.radius < 0) {
                    particle.x = new_pos.x_right;
                    particle.y = Math.random() * _this._canvasParams.height;
                }
                if (particle.y - particle.radius > _this._canvasParams.height) {
                    particle.y = new_pos.y_top;
                    particle.x = Math.random() * _this._canvasParams.width;
                }
                else if (particle.y + particle.radius < 0) {
                    particle.y = new_pos.y_bottom;
                    particle.x = Math.random() * _this._canvasParams.width;
                }
                switch (_this._params.particles.move.out_mode) {
                    case 'bounce':
                        if (particle.x + particle.radius > _this._canvasParams.width)
                            particle.vx = -particle.vx;
                        else if (particle.x - particle.radius < 0)
                            particle.vx = -particle.vx;
                        if (particle.y + particle.radius > _this._canvasParams.height)
                            particle.vy = -particle.vy;
                        else if (particle.y - particle.radius < 0)
                            particle.vy = -particle.vy;
                        break;
                }
                if (isInArray('grab', _this._params.interactivity.events.onhover.mode)) {
                    _this._grabParticle(particle);
                }
                if (isInArray('bubble', _this._params.interactivity.events.onhover.mode) ||
                    isInArray('bubble', _this._params.interactivity.events.onclick.mode)) {
                    _this._bubbleParticle(particle);
                }
                if (isInArray('repulse', _this._params.interactivity.events.onhover.mode) ||
                    isInArray('repulse', _this._params.interactivity.events.onclick.mode)) {
                    _this._repulseParticle(particle);
                }
                if (_this._params.particles.line_linked.enable || _this._params.particles.move.attract.enable) {
                    for (var j = i + 1; j < _this._params.particles.array.length; j++) {
                        var link = _this._params.particles.array[j];
                        if (_this._params.particles.line_linked.enable)
                            _this._interaction.linkParticles(particle, link, _this._params, _this._canvasParams);
                        if (_this._params.particles.move.attract.enable)
                            _this._interaction.attractParticles(particle, link, _this._params);
                        if (_this._params.particles.move.bounce)
                            _this._interaction.bounceParticles(particle, link);
                    }
                }
            });
        };
        ParticlesManager.prototype.particlesDraw = function () {
            this._canvasParams.ctx.clearRect(0, 0, this._canvasParams.width, this._canvasParams.height);
            this._particlesUpdate();
            this._params.particles.array.forEach(function (particle) {
                particle.draw();
            });
        };
        ParticlesManager.prototype.particlesEmpty = function () {
            this._params.particles.array = [];
        };
        ParticlesManager.prototype.removeParticles = function (nb) {
            this._params.particles.array.splice(0, nb);
            if (!this._params.particles.move.enable) {
                this.particlesDraw();
            }
        };
        ParticlesManager.prototype.pushParticles = function (nb, pos) {
            this._tmpParams.pushing = true;
            for (var i = 0; i < nb; i++) {
                this._params.particles.array.push(new Particle(this._canvasParams, this._params, this._tmpParams, this._params.particles.color, this._params.particles.opacity.value, {
                    x: pos ? pos.pos_x : Math.random() * this._canvasParams.width,
                    y: pos ? pos.pos_y : Math.random() * this._canvasParams.height
                }));
                if (i == nb - 1) {
                    if (!this._params.particles.move.enable) {
                        this.particlesDraw();
                    }
                    this._tmpParams.pushing = false;
                }
            }
        };
        ParticlesManager.prototype._bubbleParticle = function (particle) {
            var _this = this;
            if (this._params.interactivity.events.onhover.enable &&
                isInArray('bubble', this._params.interactivity.events.onhover.mode)) {
                var dx_mouse = particle.x - this._params.interactivity.mouse.pos_x;
                var dy_mouse = particle.y - this._params.interactivity.mouse.pos_y;
                var dist_mouse = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse);
                var ratio = 1 - dist_mouse / this._params.interactivity.modes.bubble.distance;
                var init = function () {
                    particle.opacity_bubble = particle.opacity;
                    particle.radius_bubble = particle.radius;
                };
                if (dist_mouse <= this._params.interactivity.modes.bubble.distance) {
                    if (ratio >= 0 && this._params.interactivity.status == 'mousemove') {
                        if (this._params.interactivity.modes.bubble.size != this._params.particles.size.value) {
                            if (this._params.interactivity.modes.bubble.size > this._params.particles.size.value) {
                                var size = particle.radius + (this._params.interactivity.modes.bubble.size * ratio);
                                if (size >= 0) {
                                    particle.radius_bubble = size;
                                }
                            }
                            else {
                                var dif = particle.radius - this._params.interactivity.modes.bubble.size;
                                var size = particle.radius - (dif * ratio);
                                if (size > 0) {
                                    particle.radius_bubble = size;
                                }
                                else {
                                    particle.radius_bubble = 0;
                                }
                            }
                        }
                        if (this._params.interactivity.modes.bubble.opacity != this._params.particles.opacity.value) {
                            if (this._params.interactivity.modes.bubble.opacity > this._params.particles.opacity.value) {
                                var opacity = this._params.interactivity.modes.bubble.opacity * ratio;
                                if (opacity > particle.opacity && opacity <= this._params.interactivity.modes.bubble.opacity) {
                                    particle.opacity_bubble = opacity;
                                }
                            }
                            else {
                                var opacity = particle.opacity - (this._params.particles.opacity.value - this._params.interactivity.modes.bubble.opacity) * ratio;
                                if (opacity < particle.opacity && opacity >= this._params.interactivity.modes.bubble.opacity) {
                                    particle.opacity_bubble = opacity;
                                }
                            }
                        }
                    }
                }
                else {
                    init();
                }
                if (this._params.interactivity.status == 'mouseleave') {
                    init();
                }
            }
            else if (this._params.interactivity.events.onclick.enable &&
                isInArray('bubble', this._params.interactivity.events.onclick.mode)) {
                if (this._tmpParams.bubble_clicking) {
                    var dx_mouse = particle.x - this._params.interactivity.mouse.click_pos_x;
                    var dy_mouse = particle.y - this._params.interactivity.mouse.click_pos_y;
                    var dist_mouse_1 = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse);
                    var time_spent_1 = (new Date().getTime() - this._params.interactivity.mouse.click_time) / 1000;
                    if (time_spent_1 > this._params.interactivity.modes.bubble.duration) {
                        this._tmpParams.bubble_duration_end = true;
                    }
                    if (time_spent_1 > this._params.interactivity.modes.bubble.duration * 2) {
                        this._tmpParams.bubble_clicking = false;
                        this._tmpParams.bubble_duration_end = false;
                    }
                    var process = function (bubble_param, particles_param, p_obj_bubble, p_obj, id) {
                        if (bubble_param != particles_param) {
                            if (!_this._tmpParams.bubble_duration_end) {
                                if (dist_mouse_1 <= _this._params.interactivity.modes.bubble.distance) {
                                    var obj = void 0;
                                    if (p_obj_bubble != undefined) {
                                        obj = p_obj_bubble;
                                    }
                                    else {
                                        obj = p_obj;
                                    }
                                    if (obj != bubble_param) {
                                        var value = p_obj - (time_spent_1 * (p_obj - bubble_param) / _this._params.interactivity.modes.bubble.duration);
                                        if (id == 'size')
                                            particle.radius_bubble = value;
                                        if (id == 'opacity')
                                            particle.opacity_bubble = value;
                                    }
                                }
                                else {
                                    if (id == 'size')
                                        particle.radius_bubble = undefined;
                                    if (id == 'opacity')
                                        particle.opacity_bubble = undefined;
                                }
                            }
                            else {
                                if (p_obj_bubble != undefined) {
                                    var value_tmp = p_obj - (time_spent_1 * (p_obj - bubble_param) / _this._params.interactivity.modes.bubble.duration);
                                    var dif = bubble_param - value_tmp;
                                    var value = bubble_param + dif;
                                    if (id == 'size')
                                        particle.radius_bubble = value;
                                    if (id == 'opacity')
                                        particle.opacity_bubble = value;
                                }
                            }
                        }
                    };
                    if (this._tmpParams.bubble_clicking) {
                        process(this._params.interactivity.modes.bubble.size, this._params.particles.size.value, particle.radius_bubble, particle.radius, 'size');
                        process(this._params.interactivity.modes.bubble.opacity, this._params.particles.opacity.value, particle.opacity_bubble, particle.opacity, 'opacity');
                    }
                }
            }
        };
        ParticlesManager.prototype._repulseParticle = function (particle) {
            var _this = this;
            if (this._params.interactivity.events.onhover.enable &&
                isInArray('repulse', this._params.interactivity.events.onhover.mode) &&
                this._params.interactivity.status == 'mousemove') {
                var dx_mouse = particle.x - this._params.interactivity.mouse.pos_x;
                var dy_mouse = particle.y - this._params.interactivity.mouse.pos_y;
                var dist_mouse = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse);
                var normVec = { x: dx_mouse / dist_mouse, y: dy_mouse / dist_mouse };
                var repulseRadius = this._params.interactivity.modes.repulse.distance;
                var velocity = 100;
                var repulseFactor = clamp((1 / repulseRadius) * (-1 * Math.pow(dist_mouse / repulseRadius, 2) + 1) * repulseRadius * velocity, 0, 50);
                var pos = {
                    x: particle.x + normVec.x * repulseFactor,
                    y: particle.y + normVec.y * repulseFactor
                };
                if (this._params.particles.move.out_mode == 'bounce') {
                    if (pos.x - particle.radius > 0 && pos.x + particle.radius < this._canvasParams.width)
                        particle.x = pos.x;
                    if (pos.y - particle.radius > 0 && pos.y + particle.radius < this._canvasParams.height)
                        particle.y = pos.y;
                }
                else {
                    particle.x = pos.x;
                    particle.y = pos.y;
                }
            }
            else if (this._params.interactivity.events.onclick.enable &&
                isInArray('repulse', this._params.interactivity.events.onclick.mode)) {
                if (!this._tmpParams.repulse_finish) {
                    this._tmpParams.repulse_count++;
                    if (this._tmpParams.repulse_count == this._params.particles.array.length)
                        this._tmpParams.repulse_finish = true;
                }
                if (this._tmpParams.repulse_clicking) {
                    var repulseRadius = Math.pow(this._params.interactivity.modes.repulse.distance / 6, 3);
                    var dx_1 = this._params.interactivity.mouse.click_pos_x - particle.x;
                    var dy_1 = this._params.interactivity.mouse.click_pos_y - particle.y;
                    var d = dx_1 * dx_1 + dy_1 * dy_1;
                    var force_1 = -repulseRadius / d * 1;
                    var process = function () {
                        var f = Math.atan2(dy_1, dx_1);
                        particle.vx = force_1 * Math.cos(f);
                        particle.vy = force_1 * Math.sin(f);
                        if (_this._params.particles.move.out_mode == 'bounce') {
                            var pos = {
                                x: particle.x + particle.vx,
                                y: particle.y + particle.vy
                            };
                            if (pos.x + particle.radius > _this._canvasParams.width)
                                particle.vx = -particle.vx;
                            else if (pos.x - particle.radius < 0)
                                particle.vx = -particle.vx;
                            if (pos.y + particle.radius > _this._canvasParams.height)
                                particle.vy = -particle.vy;
                            else if (pos.y - particle.radius < 0)
                                particle.vy = -particle.vy;
                        }
                    };
                    if (d <= repulseRadius) {
                        process();
                    }
                }
                else {
                    if (this._tmpParams.repulse_clicking == false) {
                        particle.vx = particle.vx_i;
                        particle.vy = particle.vy_i;
                    }
                }
            }
        };
        ParticlesManager.prototype._grabParticle = function (particle) {
            var _a = this._params, interactivity = _a.interactivity, particles = _a.particles;
            if (interactivity.events.onhover.enable &&
                interactivity.status == 'mousemove') {
                var dx_mouse = particle.x - interactivity.mouse.pos_x;
                var dy_mouse = particle.y - interactivity.mouse.pos_y;
                var dist_mouse = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse);
                if (dist_mouse <= interactivity.modes.grab.distance) {
                    var grab = interactivity.modes.grab;
                    var opacity_line = grab.line_linked.opacity - (dist_mouse / (1 / grab.line_linked.opacity)) / grab.distance;
                    if (opacity_line > 0) {
                        var color_line = particles.line_linked.color_rgb_line;
                        var r = color_line.r, g = color_line.g, b = color_line.b;
                        this._canvasParams.ctx.strokeStyle = "rgba( " + r + ", " + g + ", " + b + ", " + opacity_line + " )";
                        this._canvasParams.ctx.lineWidth = particles.line_linked.width;
                        this._canvasParams.ctx.beginPath();
                        this._canvasParams.ctx.moveTo(particle.x, particle.y);
                        this._canvasParams.ctx.lineTo(interactivity.mouse.pos_x, interactivity.mouse.pos_y);
                        this._canvasParams.ctx.stroke();
                        this._canvasParams.ctx.closePath();
                    }
                }
            }
        };
        return ParticlesManager;
    }());

    var CanvasManager = /** @class */ (function () {
        function CanvasManager(_canvasParams, _params, _tmpParams) {
            this._canvasParams = _canvasParams;
            this._params = _params;
            this._tmpParams = _tmpParams;
            this._onWindowResize = this._onWindowResize.bind(this);
            this._retinaInit();
            this._canvasSize();
            this.particlesManager = new ParticlesManager(this._canvasParams, this._params, this._tmpParams);
            this.particlesManager.particlesCreate();
            this._densityAutoParticles();
            var particles = this._params.particles;
            particles.line_linked.color_rgb_line = hexToRgb(particles.line_linked.color);
        }
        CanvasManager.prototype.cancelAnimation = function () {
            if (!this._tmpParams.drawAnimFrame) {
                return;
            }
            cancelAnimationFrame(this._tmpParams.drawAnimFrame);
            this._tmpParams.drawAnimFrame = null;
        };
        CanvasManager.prototype.draw = function () {
            var particles = this._params.particles;
            if (particles.shape.type == 'image') {
                if (this._tmpParams.img_type == 'svg') {
                    if (this._tmpParams.count_svg >= particles.number.value) {
                        this.particlesManager.particlesDraw();
                        if (!particles.move.enable) {
                            cancelAnimationFrame(this._tmpParams.drawAnimFrame);
                        }
                        else {
                            this._tmpParams.drawAnimFrame = requestAnimationFrame(this.draw.bind(this));
                        }
                    }
                    else {
                        if (!this._tmpParams.img_error) {
                            this._tmpParams.drawAnimFrame = requestAnimationFrame(this.draw.bind(this));
                        }
                    }
                }
                else {
                    if (this._tmpParams.img_obj != undefined) {
                        this.particlesManager.particlesDraw();
                        if (!particles.move.enable) {
                            cancelAnimationFrame(this._tmpParams.drawAnimFrame);
                        }
                        else {
                            this._tmpParams.drawAnimFrame = requestAnimationFrame(this.draw.bind(this));
                        }
                    }
                    else {
                        if (!this._tmpParams.img_error) {
                            this._tmpParams.drawAnimFrame = requestAnimationFrame(this.draw.bind(this));
                        }
                    }
                }
            }
            else {
                this.particlesManager.particlesDraw();
                if (!particles.move.enable) {
                    cancelAnimationFrame(this._tmpParams.drawAnimFrame);
                }
                else {
                    this._tmpParams.drawAnimFrame = requestAnimationFrame(this.draw.bind(this));
                }
            }
        };
        CanvasManager.prototype._densityAutoParticles = function () {
            var particles = this._params.particles;
            if (particles.number.density.enable) {
                var area = this._canvasParams.el.width * this._canvasParams.el.height / 1000;
                if (this._tmpParams.retina) {
                    area = area / (this._canvasParams.pxratio * 2);
                }
                var nb_particles = area * particles.number.value / particles.number.density.value_area;
                var missing_particles = particles.array.length - nb_particles;
                if (missing_particles < 0) {
                    this.particlesManager.pushParticles(Math.abs(missing_particles));
                }
                else {
                    this.particlesManager.removeParticles(missing_particles);
                }
            }
        };
        CanvasManager.prototype._retinaInit = function () {
            if (this._params.retina_detect && window.devicePixelRatio > 1) {
                this._canvasParams.pxratio = window.devicePixelRatio;
                this._tmpParams.retina = true;
                this._canvasParams.width = this._canvasParams.el.offsetWidth * this._canvasParams.pxratio;
                this._canvasParams.height = this._canvasParams.el.offsetHeight * this._canvasParams.pxratio;
                this._params.particles.size.value = this._tmpParams.obj.size_value * this._canvasParams.pxratio;
                this._params.particles.size.anim.speed = this._tmpParams.obj.size_anim_speed * this._canvasParams.pxratio;
                this._params.particles.move.speed = this._tmpParams.obj.move_speed * this._canvasParams.pxratio;
                this._params.particles.line_linked.distance = this._tmpParams.obj.line_linked_distance * this._canvasParams.pxratio;
                this._params.interactivity.modes.grab.distance = this._tmpParams.obj.mode_grab_distance * this._canvasParams.pxratio;
                this._params.interactivity.modes.bubble.distance = this._tmpParams.obj.mode_bubble_distance * this._canvasParams.pxratio;
                this._params.particles.line_linked.width = this._tmpParams.obj.line_linked_width * this._canvasParams.pxratio;
                this._params.interactivity.modes.bubble.size = this._tmpParams.obj.mode_bubble_size * this._canvasParams.pxratio;
                this._params.interactivity.modes.repulse.distance = this._tmpParams.obj.mode_repulse_distance * this._canvasParams.pxratio;
            }
            else {
                this._canvasParams.pxratio = 1;
                this._tmpParams.retina = false;
            }
        };
        CanvasManager.prototype._canvasClear = function () {
            this._canvasParams.ctx.clearRect(0, 0, this._canvasParams.width, this._canvasParams.height);
        };
        CanvasManager.prototype._canvasPaint = function () {
            this._canvasParams.ctx.fillRect(0, 0, this._canvasParams.width, this._canvasParams.height);
        };
        CanvasManager.prototype._canvasSize = function () {
            this._canvasParams.el.width = this._canvasParams.width;
            this._canvasParams.el.height = this._canvasParams.height;
            if (this._params && this._params.interactivity.events.resize) {
                window.addEventListener('resize', this._onWindowResize);
            }
        };
        CanvasManager.prototype._onWindowResize = function () {
            this._canvasParams.width = this._canvasParams.el.offsetWidth;
            this._canvasParams.height = this._canvasParams.el.offsetHeight;
            if (this._tmpParams.retina) {
                this._canvasParams.width *= this._canvasParams.pxratio;
                this._canvasParams.height *= this._canvasParams.pxratio;
            }
            this._canvasParams.el.width = this._canvasParams.width;
            this._canvasParams.el.height = this._canvasParams.height;
            if (!this._params.particles.move.enable) {
                this.particlesManager.particlesEmpty();
                this.particlesManager.particlesCreate();
                this.particlesManager.particlesDraw();
                this._densityAutoParticles();
            }
            this._densityAutoParticles();
        };
        return CanvasManager;
    }());

    var ParticlesDirective = /** @class */ (function () {
        function ParticlesDirective(el) {
            this.el = el;
            this._tmpParams = {};
        }
        Object.defineProperty(ParticlesDirective.prototype, "params", {
            set: function (value) {
                var defaultParams = getDefaultParams();
                this._params = deepExtend(defaultParams, value);
            },
            enumerable: true,
            configurable: true
        });
        ParticlesDirective.prototype.ngOnDestroy = function () {
            if (!this._canvasManager) {
                return;
            }
            this._canvasManager.cancelAnimation();
        };
        ParticlesDirective.prototype.ngAfterViewInit = function () {
            this._canvasParams = {
                el: this.el.nativeElement,
                ctx: this.el.nativeElement.getContext('2d'),
                width: this.el.nativeElement.offsetWidth,
                height: this.el.nativeElement.offsetHeight
            };
            this._tmpParams.obj = {
                size_value: this._params.particles.size.value,
                size_anim_speed: this._params.particles.size.anim.speed,
                move_speed: this._params.particles.move.speed,
                line_linked_distance: this._params.particles.line_linked.distance,
                line_linked_width: this._params.particles.line_linked.width,
                mode_grab_distance: this._params.interactivity.modes.grab.distance,
                mode_bubble_distance: this._params.interactivity.modes.bubble.distance,
                mode_bubble_size: this._params.interactivity.modes.bubble.size,
                mode_repulse_distance: this._params.interactivity.modes.repulse.distance
            };
            this._params.interactivity.el = (this._params.interactivity.detect_on == 'window') ? window : this._canvasParams.el;
            if (isInArray('image', this._params.particles.shape.type)) {
                this._tmpParams.img_type = this._params.particles.shape.image.src.substr(this._params.particles.shape.image.src.length - 3);
                loadImg(this._params, this._tmpParams);
            }
            this._canvasManager = new CanvasManager(this._canvasParams, this._params, this._tmpParams);
            this._canvasManager.draw();
        };
        /**
         * Mouse move event
         * @param event
         */
        ParticlesDirective.prototype.onMouseMove = function (event) {
            var interactivity = this._params.interactivity;
            if (interactivity.events.onhover.enable ||
                interactivity.events.onclick.enable) {
                var pos = void 0;
                if (interactivity.el == window) {
                    pos = {
                        x: event.clientX,
                        y: event.clientY
                    };
                }
                else {
                    pos = {
                        x: event.offsetX || event.clientX,
                        y: event.offsetY || event.clientY
                    };
                }
                interactivity.mouse.pos_x = pos.x;
                interactivity.mouse.pos_y = pos.y;
                if (this._tmpParams.retina) {
                    interactivity.mouse.pos_x *= this._canvasParams.pxratio;
                    interactivity.mouse.pos_y *= this._canvasParams.pxratio;
                }
                interactivity.status = 'mousemove';
            }
        };
        /**
         * Mouse leave event
         */
        ParticlesDirective.prototype.onMouseLeave = function () {
            var interactivity = this._params.interactivity;
            if (interactivity.events.onhover.enable ||
                interactivity.events.onclick.enable) {
                interactivity.mouse.pos_x = null;
                interactivity.mouse.pos_y = null;
                interactivity.status = 'mouseleave';
            }
        };
        /**
         * Click event
         */
        ParticlesDirective.prototype.onClick = function () {
            var _this = this;
            var _a = this._params, interactivity = _a.interactivity, particles = _a.particles;
            if (interactivity.events.onclick.enable) {
                interactivity.mouse.click_pos_x = interactivity.mouse.pos_x;
                interactivity.mouse.click_pos_y = interactivity.mouse.pos_y;
                interactivity.mouse.click_time = new Date().getTime();
                switch (interactivity.events.onclick.mode) {
                    case 'push':
                        if (particles.move.enable) {
                            this._canvasManager.particlesManager.pushParticles(interactivity.modes.push.particles_nb, interactivity.mouse);
                        }
                        else {
                            if (interactivity.modes.push.particles_nb == 1) {
                                this._canvasManager.particlesManager.pushParticles(interactivity.modes.push.particles_nb, interactivity.mouse);
                            }
                            else if (interactivity.modes.push.particles_nb > 1) {
                                this._canvasManager.particlesManager.pushParticles(interactivity.modes.push.particles_nb);
                            }
                        }
                        break;
                    case 'remove':
                        this._canvasManager.particlesManager.removeParticles(interactivity.modes.remove.particles_nb);
                        break;
                    case 'bubble':
                        this._tmpParams.bubble_clicking = true;
                        break;
                    case 'repulse':
                        this._tmpParams.repulse_clicking = true;
                        this._tmpParams.repulse_count = 0;
                        this._tmpParams.repulse_finish = false;
                        setTimeout(function () {
                            _this._tmpParams.repulse_clicking = false;
                        }, interactivity.modes.repulse.duration * 1000);
                        break;
                }
            }
        };
        ParticlesDirective.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], ParticlesDirective.prototype, "params", null);
        __decorate([
            core.HostListener('mousemove', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], ParticlesDirective.prototype, "onMouseMove", null);
        __decorate([
            core.HostListener('mouseleave'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], ParticlesDirective.prototype, "onMouseLeave", null);
        __decorate([
            core.HostListener('click'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], ParticlesDirective.prototype, "onClick", null);
        ParticlesDirective = __decorate([
            core.Directive({
                selector: '[d-particles]'
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], ParticlesDirective);
        return ParticlesDirective;
    }());

    var ParticlesModule = /** @class */ (function () {
        function ParticlesModule() {
        }
        ParticlesModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule
                ],
                declarations: [
                    ParticlesComponent,
                    ParticlesDirective
                ],
                exports: [
                    ParticlesComponent,
                    ParticlesDirective
                ]
            })
        ], ParticlesModule);
        return ParticlesModule;
    }());

    exports.CanvasManager = CanvasManager;
    exports.Particle = Particle;
    exports.ParticleInteraction = ParticleInteraction;
    exports.ParticlesComponent = ParticlesComponent;
    exports.ParticlesDirective = ParticlesDirective;
    exports.ParticlesManager = ParticlesManager;
    exports.ParticlesModule = ParticlesModule;
    exports.clamp = clamp;
    exports.createSvgImg = createSvgImg;
    exports.deepExtend = deepExtend;
    exports.getColor = getColor;
    exports.getDefaultParams = getDefaultParams;
    exports.hexToRgb = hexToRgb;
    exports.isInArray = isInArray;
    exports.loadImg = loadImg;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-particle.umd.js.map
